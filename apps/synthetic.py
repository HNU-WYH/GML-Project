import os
import numpy as np
import torch

import warnings
import scipy.sparse as sp
import scipy.sparse.linalg as spla
from tqdm import tqdm

from apps.data import matrix_to_graph
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

def generate_sparse_random(n: int, alpha: int =1e-4, sparsity: float = 1e-3, random_state: int =0, sol: bool =False, ood: bool =False):
    """
    Generate a sparse SPD linear system A, x, b. The matrix A is generated based on Cholesky decomposition A = MM^T + \alpha I,
    the vector b is generated by uniform distribution between [0, 1],
    the vector x is obtained by solving the linear system Ax=b (optional).

    :param n: The dimension of the square matrix A (size n × n).
    :param alpha: Diagonal parameter to ensure strict positive definiteness (A = MM^T + \alpha I), Default is 1e-4.
    :param sparsity: The ratio of non_zero entries in the matrix A
    :param random_state: Seed for the random number generator. Default is 0.
    :param sol: whether you solve the linear system Ax = b to get x or not
    :param ood: whether generate an “out-of-distribution” sample by varying the sparsity
    :return: A, x, b
    """

    # Random state
    rng = np.random.RandomState(random_state)

    # if alpha is not defined
    if alpha is None:
        alpha = rng.uniform(1e-4, 1e-2)

    # create out of distribution samples
    if ood:
        factor = rng.uniform(0.1, 10)
        sparsity = factor * sparsity

    # define sparsity, number of non-zero entries
    nnz = int(sparsity * n ** 2)

    # define the coordinate oof each non-zero entries
    rows = [rng.randint(0, n) for _ in range(nnz)]
    cols = [rng.randint(0, n) for _ in range(nnz)]

    # there might be overlapping, use uniques only
    uniques = set(zip(rows, cols))
    rows, cols = zip(*uniques)

    # generate values based on unique coordinates
    vals = np.array([rng.normal(0, 1) for _ in cols])

    # create spd matrix
    M = sp.coo_matrix((vals, (rows, cols)), shape=(n, n))
    I = sp.identity(n)
    A = (M @ M.T) + alpha * I
    # print(f"Generated matrix with {100 * (A.nnz / n ** 2) :.2f}% non-zero elements: ({A.nnz} non-zeros)")

    # generate right hand side vector based on uniform distribution
    b = rng.uniform(0, 1, size=n)

    # compute the solution
    if sol:
        # generate solution using dense method for accuracy reasons
        x, _ = spla.cg(A, b)

    else:
        x = None

    return A, x, b


def create_dataset(n, samples, alpha=1e-4, sparsity: float = 1e-3, graph=True, rs=0, mode='train', solution=False):
    """
    generate a batch of linear system, convert into graph data (optional), and save into .npz file or .pt file
    :param n: size of matrix n × n
    :param samples: num of samples
    :param alpha: MM^T + alpha I
    :param graph: whether convert the matrix to graph
    :param rs: the initial seed of random state
    :param mode: the mode of dataset, 'train', 'val', 'test', 'test_ood'
    :param solution: whether compute Ax=b and store x, usually store solution for test/val
    :return:
    """
    if mode != 'train':
        warnings.warn('rs must be set for test and val to avoid overlap')

    print(f"Generating {samples} samples for the {mode} dataset.")

    for sam in tqdm(range(samples)):
        A, x, b = generate_sparse_random(n, random_state=(rs + sam), alpha=alpha, sparsity=sparsity, sol=solution,
                                         ood=(mode == "test_ood"))
        if graph:
            graph = matrix_to_graph(A, b)
            if x is not None:
                graph.s = torch.tensor(x, dtype=torch.float)
            graph.n = n
            os.makedirs(f'./dataset/{mode}', exist_ok=True)
            torch.save(graph, f'./dataset/{mode}/{n}_{sam}.pt')
        else:
            A = sp.coo_matrix(A)
            os.makedirs(f'./dataset/{mode}', exist_ok=True)
            np.savez(f'./dataset/{mode}/{n}_{sam}.npz', A=A, b=b, x=x)


if __name__ == '__main__':
    # create 10k dataset
    n = 10_000
    alpha=10e-4
    
    create_dataset(n, 1000, alpha=alpha, mode='train', rs=0, graph=True, solution=True)
    create_dataset(n, 10, alpha=alpha, mode='val', rs=10000, graph=True, solution=True)
    create_dataset(n, 100, alpha=alpha, mode='test', rs=103600, graph=True, solution=True)
