"""
Two methods are used in generating the sparse matrices in original work:
1. A = MM^T + \alpha I
2. numerical simulation of Poisson Equation (deprecated)

The first one can use different sparsity. However, for the 2nd one, the sparsity is typically very small (less than 0.1%),
unless using very high order very high order spectral method or discontinuous galerkin, that is hard to implement unless
we use professional library that will beyond our scope.

But there still are some cases in really that use large dense matrix needed to be solved similar to the 1st case, for example:
1. for graph regularization, to smooth the graph signal, we need to compute the following minimization problem
     \|x - y\|^2 + \alpha * x^TLx
    this is equivalent to compute (L + 1/alpha I) x = y, similar to our data generation A = MM^T + \alpha I
2. for very old-style rating system, we hava a sparse rating system R (m×n), R_ij represents the rating of user i to item j.
R_ij is sparse because we only have limited data, we can use the following minimization problem
    |R - UV^T|^2_F + \lambda_1 |U|^2_F + \lambda_1 |V|^2_F
    where row i of U represents the feature of user_i, row j of V represents the feature of item_j.
    we need regularization to make the system invertible and prevents overfitting.
    the solution can be obtained by alternating least square, for example, fixed U or V and solve the remaining
        1. (U^T U + \lambda I)v_j = U^T r^j
        2. (V^T V + \lambda I)u_j = V^T r^j

Thus, we focus only on the first case will be enough and Persuasive.
"""
import numpy as np
import os, torch, scipy
import scipy.sparse as sp
import scipy.sparse.linalg as spla
from debugpy.common.log import warning

from data.matrix_2_graph import matrix_to_graph

# In[]: A = MM^T + \alpha I
def generate_sparse_random(n: int, alpha: int =1e-4, sparsity: float = 1e-3, random_state: int =0, sol: bool =False, ood: bool =False):
    """
    Generate a sparse SPD linear system A, x, b. The matrix A is generated based on Cholesky decomposition A = MM^T + \alpha I,
    the vector b is generated by uniform distribution between [0, 1],
    the vector x is obtained by solving the linear system Ax=b (optional).

    :param n: The dimension of the square matrix A (size n × n).
    :param alpha: Diagonal parameter to ensure strict positive definiteness (A = MM^T + \alpha I), Default is 1e-4.
    :param sparsity: The ratio of non_zero entries in the matrix A
    :param random_state: Seed for the random number generator. Default is 0.
    :param sol: whether you solve the linear system Ax = b to get x or not
    :param ood: whether generate an “out-of-distribution” sample by varying the sparsity
    :return: A, x, b
    """

    # Random state
    rng = np.random.RandomState(random_state)

    # if alpha is not defined
    if alpha is None:
        alpha = rng.uniform(1e-4, 1e-2)

    # create out of distribution samples
    if ood:
        factor = rng.uniform(0.1, 10)
        sparsity = factor * sparsity

    # define sparsity, number of non-zero entries
    nnz = int(sparsity * n ** 2)

    # define the coordinate oof each non-zero entries
    rows = [rng.randint(0, n) for _ in range(nnz)]
    cols = [rng.randint(0, n) for _ in range(nnz)]

    # there might be overlapping, use uniques only
    uniques = set(zip(rows, cols))
    rows, cols = zip(*uniques)

    # generate values based on unique coordinates
    vals = np.array([rng.normal(0, 1) for _ in cols])

    # create spd matrix
    M = sp.coo_matrix((vals, (rows, cols)), shape=(n, n))
    I = sp.identity(n)
    A = (M @ M.T) + alpha * I
    # print(f"Generated matrix with {100 * (A.nnz / n ** 2) :.2f}% non-zero elements: ({A.nnz} non-zeros)")

    # generate right hand side vector based on uniform distribution
    b = rng.uniform(0, 1, size=n)

    # compute the solution
    if sol:
        # generate solution using dense method for accuracy reasons
        x, _ = spla.cg(A, b)

    else:
        x = None

    return A, x, b

# In[]: Create the denser matrix dataset
def create_dataset(n, samples, alpha=1e-4, graph=True, rs=0, mode='train', solution=False):
    """
    generate a batch of linear system, convert into graph data (optional), and save into .npz file or .pt file
    :param n: size of matrix n × n
    :param samples: num of samples
    :param alpha: MM^T + alpha I
    :param graph: whether convert the matrix to graph
    :param rs: the initial seed of random state
    :param mode: the mode of dataset, 'train', 'val', 'test', 'test_ood'
    :param solution: whether compute Ax=b and store x, usually store solution for test/val
    :return:
    """
    if mode != 'train':
        warning('rs must be set for test and val to avoid overlap')

    print(f"Generating {samples} samples for the {mode} dataset.")

    for sam in range(samples):
        A, x, b = generate_sparse_random(n, random_state=(rs + sam), alpha=alpha, sol=solution,
                                         ood=(mode == "test_ood"))
        if graph:
            graph = matrix_to_graph(A, b)
            if x is not None:
                graph.s = torch.tensor(x, dtype=torch.float)
            graph.n = n
            os.makedirs(f'./dataset/{mode}', exist_ok=True)
            torch.save(graph, f'./dataset/{mode}/{n}_{sam}.pt')
        else:
            A = sp.coo_matrix(A)
            os.makedirs(f'./dataset/{mode}', exist_ok=True)
            np.savez(f'./dataset/{mode}/{n}_{sam}.npz', A=A, b=b, x=x)

# In[]:
if __name__ == "__main__":
    n = 10_000
    alpha = 10e-4
    # the random seed should [rs, rs+samples] should not overlap with each other to avoid overlapping in dataset
    create_dataset(n, samples=1000, alpha=alpha, mode='train', rs=0, graph=True, solution=True)
    create_dataset(n, samples=10, alpha=alpha, mode='val', rs=10000, graph=True)
    create_dataset(n, samples=100, alpha=alpha, mode='test', rs=103600, graph=True)



